#!/bin/bash
#
# setup.sh - Setup wizard steps
#
# This file is sourced by setup-gateway.sh
# Requires: common.sh (including logging), validation.sh, file_ops.sh, service.sh, gps.sh
#
# Expected global variables from main script:
#   SCRIPT_DIR, CUPS_DIR, BUILD_DIR, STATION_BINARY
#   CHIP_ID_DIR, CHIP_ID_SOURCE, CHIP_ID_LOG_STUB, CHIP_ID_TOOL
#   RESET_LGW_SCRIPT, BOARD_CONF, BOARD_CONF_TEMPLATE
#   TTN_REGION, CUPS_URI, GATEWAY_EUI, CUPS_KEY, LOG_FILE, GPS_DEVICE
#   BOARD_TYPE, SX1302_RESET_BCM, SX1302_POWER_EN_BCM
#   SKIP_DEPS
#

#######################################
# Build Functions
#######################################

build_chip_id() {
    local lgw_inc="$BUILD_DIR/include/lgw"
    local lgw_lib="$BUILD_DIR/lib"

    if [[ ! -d "$lgw_inc" ]] || [[ ! -f "$lgw_lib/liblgw1302.a" ]]; then
        print_warning "Cannot build chip_id: libloragw not found (station build required first)"
        return 1
    fi

    if [[ ! -f "$CHIP_ID_SOURCE" ]]; then
        print_warning "Cannot build chip_id: source file not found at $CHIP_ID_SOURCE"
        return 1
    fi

    echo "  Building chip_id tool..."
    local build_err
    build_err=$(mktemp)

    if gcc -std=gnu11 -O2 \
        -I"$lgw_inc" \
        "$CHIP_ID_SOURCE" "$CHIP_ID_LOG_STUB" \
        -L"$lgw_lib" -llgw1302 -lm -lpthread -lrt \
        -o "$CHIP_ID_TOOL" 2>"$build_err"; then
        rm -f "$build_err"
        echo "  Created: $CHIP_ID_TOOL"
        return 0
    else
        print_warning "  Failed to build chip_id (non-critical, manual EUI entry available)"
        if [[ -s "$build_err" ]]; then
            echo "  Build error:"
            sed 's/^/    /' "$build_err"
        fi
        rm -f "$build_err"
        return 1
    fi
}

#######################################
# Setup Step Functions
#######################################

step_check_existing_credentials() {
    if file_exists "$CUPS_DIR/cups.key"; then
        print_warning "Warning: Credentials already exist in $CUPS_DIR"
        # In non-interactive mode, check FORCE_OVERWRITE flag
        if [[ "$NON_INTERACTIVE" == true ]]; then
            if [[ "$FORCE_OVERWRITE" != true ]]; then
                print_error "Credentials already exist. Use --force to overwrite."
                exit 1
            fi
            log_info "Force overwrite enabled, proceeding..."
        elif ! confirm "Do you want to overwrite them?"; then
            echo "Setup cancelled."
            exit 0
        fi
    fi
}

step_select_board() {
    local sx1261_reset_bcm

    # Use CLI value if provided
    if [[ -n "$CLI_BOARD" ]]; then
        BOARD_TYPE="$CLI_BOARD"
        if get_board_config "$BOARD_TYPE"; then
            sx1261_reset_bcm="$SX1261_RESET_BCM"
            log_info "Using board from CLI: $BOARD_TYPE"
            if [[ "$NON_INTERACTIVE" != true ]]; then
                echo -e "Using board: ${GREEN}$BOARD_TYPE${NC}"
                echo -e "  Reset: GPIO $SX1302_RESET_BCM, Power EN: GPIO $SX1302_POWER_EN_BCM, SX1261: GPIO $sx1261_reset_bcm"
                echo ""
            fi
        else
            print_error "Error: Could not get configuration for board: $CLI_BOARD"
            exit 1
        fi

        # Save board configuration
        cat > "$BOARD_CONF" << EOF
# Board configuration for SX1302 concentrator
# Generated by setup-gateway.sh on $(date)
#
# To use a different board, re-run setup-gateway.sh or edit this file.
# BCM pin numbers are converted to actual GPIO numbers by reset_lgw.sh
#
BOARD_TYPE=$BOARD_TYPE
SX1302_RESET_BCM=$SX1302_RESET_BCM
SX1302_POWER_EN_BCM=$SX1302_POWER_EN_BCM
SX1261_RESET_BCM=$sx1261_reset_bcm
EOF

        if [[ "$NON_INTERACTIVE" != true ]]; then
            print_success "Board configuration saved to $BOARD_CONF"
        fi
        log_info "Board selected: $BOARD_TYPE (Reset=$SX1302_RESET_BCM, PowerEN=$SX1302_POWER_EN_BCM, SX1261=$sx1261_reset_bcm)"
        return 0
    fi

    print_header "Step 1: Select your concentrator board"
    echo ""
    echo "Which SX1302 concentrator board are you using?"
    echo ""

    # Check if template exists
    if [[ ! -f "$BOARD_CONF_TEMPLATE" ]]; then
        print_error "Error: Board template file not found: $BOARD_CONF_TEMPLATE"
        exit 1
    fi

    # Read board definitions from template (skip comments and empty lines)
    local -a board_types=()
    local -a board_descs=()
    local -a board_reset_pins=()
    local -a board_power_pins=()
    local -a board_sx1261_pins=()
    local index=1

    while IFS=: read -r btype bdesc breset bpower bsx1261; do
        # Skip comments and empty lines
        [[ "$btype" =~ ^#.*$ || -z "$btype" ]] && continue

        board_types+=("$btype")
        board_descs+=("$bdesc")
        board_reset_pins+=("$breset")
        board_power_pins+=("$bpower")
        board_sx1261_pins+=("${bsx1261:-5}")  # Default to 5 if not specified

        echo "  $index) $btype - $bdesc"
        echo "     Reset: GPIO $breset, Power EN: GPIO $bpower, SX1261: GPIO ${bsx1261:-5}"
        echo ""
        ((index++))
    done < "$BOARD_CONF_TEMPLATE"

    local board_count=${#board_types[@]}
    local manual_option=$((board_count + 1))

    echo "  $manual_option) Manual configuration"
    echo "     Specify custom GPIO pins"
    echo ""

    local board_choice
    read -rp "Enter choice [1-$manual_option]: " board_choice

    # Validate input
    if ! [[ "$board_choice" =~ ^[0-9]+$ ]] || [ "$board_choice" -lt 1 ] || [ "$board_choice" -gt "$manual_option" ]; then
        print_error "Invalid selection. Please try again."
        step_select_board
        return
    fi

    if [ "$board_choice" -eq "$manual_option" ]; then
        # Manual configuration
        BOARD_TYPE="CUSTOM"
        echo ""
        print_header "Manual GPIO Configuration"
        echo "Enter BCM GPIO pin numbers (0-27):"
        echo ""

        while true; do
            read -rp "SX1302 Reset pin (BCM): " SX1302_RESET_BCM
            if validate_gpio "$SX1302_RESET_BCM"; then
                break
            fi
            print_error "Invalid GPIO pin. Please enter a number between 0 and 27."
        done

        while true; do
            read -rp "Power Enable pin (BCM): " SX1302_POWER_EN_BCM
            if validate_gpio "$SX1302_POWER_EN_BCM"; then
                break
            fi
            print_error "Invalid GPIO pin. Please enter a number between 0 and 27."
        done

        while true; do
            read -rp "SX1261 Reset pin (BCM) [5]: " sx1261_reset_bcm
            sx1261_reset_bcm="${sx1261_reset_bcm:-5}"
            if validate_gpio "$sx1261_reset_bcm"; then
                break
            fi
            print_error "Invalid GPIO pin. Please enter a number between 0 and 27."
        done
    else
        # Predefined board
        local idx=$((board_choice - 1))
        BOARD_TYPE="${board_types[$idx]}"
        SX1302_RESET_BCM="${board_reset_pins[$idx]}"
        SX1302_POWER_EN_BCM="${board_power_pins[$idx]}"
        sx1261_reset_bcm="${board_sx1261_pins[$idx]}"
    fi

    echo ""
    echo -e "Board type: ${GREEN}$BOARD_TYPE${NC}"
    echo -e "SX1302 Reset pin: ${GREEN}GPIO $SX1302_RESET_BCM (BCM)${NC}"
    echo -e "Power Enable pin: ${GREEN}GPIO $SX1302_POWER_EN_BCM (BCM)${NC}"
    echo -e "SX1261 Reset pin: ${GREEN}GPIO $sx1261_reset_bcm (BCM)${NC}"
    echo ""

    if ! confirm "Is this correct?" "y"; then
        step_select_board
        return
    fi

    # Save board configuration
    cat > "$BOARD_CONF" << EOF
# Board configuration for SX1302 concentrator
# Generated by setup-gateway.sh on $(date)
#
# To use a different board, re-run setup-gateway.sh or edit this file.
# BCM pin numbers are converted to actual GPIO numbers by reset_lgw.sh
#
BOARD_TYPE=$BOARD_TYPE
SX1302_RESET_BCM=$SX1302_RESET_BCM
SX1302_POWER_EN_BCM=$SX1302_POWER_EN_BCM
SX1261_RESET_BCM=$sx1261_reset_bcm
EOF

    print_success "Board configuration saved to $BOARD_CONF"
    log_info "Board selected: $BOARD_TYPE (Reset=$SX1302_RESET_BCM, PowerEN=$SX1302_POWER_EN_BCM, SX1261=$sx1261_reset_bcm)"
    echo ""
}

step_build_station() {
    # Check if we should skip build
    if [[ "$CLI_SKIP_BUILD" == true ]] && file_exists "$STATION_BINARY"; then
        log_info "Skipping build (--skip-build flag and binary exists)"
        if [[ "$NON_INTERACTIVE" != true ]]; then
            print_success "Skipping build (binary exists at $STATION_BINARY)"
        fi
        # Still try to build chip_id if it doesn't exist
        if ! file_executable "$CHIP_ID_TOOL"; then
            build_chip_id || true
        fi
        return 0
    fi

    # In non-interactive mode with skip-build but no binary, we must build
    if [[ "$CLI_SKIP_BUILD" == true ]] && ! file_exists "$STATION_BINARY"; then
        log_warning "--skip-build specified but binary not found, building..."
    fi

    if [[ "$NON_INTERACTIVE" != true ]]; then
        print_header "Step 2: Build the station binary"
        echo ""
        echo "This step will compile the Basic Station software for the SX1302 Corecell platform."
        echo ""
        echo "The build process will:"
        echo "  - Download and compile dependencies (mbedTLS, libloragw)"
        echo "  - Compile the Basic Station source code"
        echo "  - Create the executable at: build-corecell-std/bin/station"
        echo "  - Build the chip_id tool for EUI detection"
        echo ""
    fi

    if file_exists "$STATION_BINARY"; then
        if [[ "$NON_INTERACTIVE" != true ]]; then
            print_warning "Note: A station binary already exists."
            if ! confirm "Do you want to rebuild?"; then
                print_success "Skipping build, using existing binary."
                # Still try to build chip_id if it doesn't exist
                if ! file_executable "$CHIP_ID_TOOL"; then
                    build_chip_id || true
                fi
                echo ""
                return 0
            fi
        else
            # Non-interactive mode: skip rebuild if binary exists (unless explicitly asked to rebuild)
            log_info "Binary exists, skipping rebuild in non-interactive mode"
            # Still try to build chip_id if it doesn't exist
            if ! file_executable "$CHIP_ID_TOOL"; then
                build_chip_id || true
            fi
            return 0
        fi
    fi

    if [[ "$NON_INTERACTIVE" != true ]]; then
        if ! confirm "Start the build process now?" "y"; then
            echo "Setup cancelled. You can build manually with:"
            echo "  make platform=corecell variant=std"
            exit 0
        fi
        echo ""
        print_warning "Building... This may take several minutes on first build."
        echo ""
    else
        log_info "Starting build in non-interactive mode..."
    fi

    cd "$SCRIPT_DIR"
    if make platform=corecell variant=std; then
        if [[ "$NON_INTERACTIVE" != true ]]; then
            echo ""
            print_success "Station build completed successfully."
        fi
        log_info "Station build completed successfully"
        build_chip_id || true
    else
        print_error "Build failed. Please check the error messages above."
        echo "You can try building manually with: make platform=corecell variant=std"
        exit 1
    fi
    if [[ "$NON_INTERACTIVE" != true ]]; then
        echo ""
    fi
}

step_select_region() {
    # Use CLI value if provided
    if [[ -n "$CLI_REGION" ]]; then
        TTN_REGION="$CLI_REGION"
        CUPS_URI="https://${TTN_REGION}.cloud.thethings.network:443"
        log_info "Using region from CLI: $TTN_REGION"
        if [[ "$NON_INTERACTIVE" != true ]]; then
            echo -e "Using region: ${GREEN}$CUPS_URI${NC}"
            echo ""
        fi
        return 0
    fi

    print_header "Step 3: Select your TTN region"
    echo "  1) EU1  - Europe (eu1.cloud.thethings.network)"
    echo "  2) NAM1 - North America (nam1.cloud.thethings.network)"
    echo "  3) AU1  - Australia (au1.cloud.thethings.network)"
    echo ""

    local region_choice
    read -rp "Enter region number [1-3]: " region_choice

    case $region_choice in
        1) TTN_REGION="eu1" ;;
        2) TTN_REGION="nam1" ;;
        3) TTN_REGION="au1" ;;
        *)
            print_warning "Invalid selection. Defaulting to EU1."
            TTN_REGION="eu1"
            ;;
    esac

    CUPS_URI="https://${TTN_REGION}.cloud.thethings.network:443"
    echo -e "Selected: ${GREEN}$CUPS_URI${NC}"
    echo ""
}

step_detect_eui() {
    local detected_eui=""

    # Use CLI value if provided (and not 'auto')
    if [[ -n "$CLI_EUI" && "$CLI_EUI" != "auto" ]]; then
        GATEWAY_EUI=$(printf '%s' "$CLI_EUI" | tr '[:lower:]' '[:upper:]')
        log_info "Using EUI from CLI: $GATEWAY_EUI"
        if [[ "$NON_INTERACTIVE" != true ]]; then
            echo -e "Using Gateway EUI: ${GREEN}$GATEWAY_EUI${NC}"
            echo ""
        fi
        return 0
    fi

    # Auto-detection mode (either explicit 'auto' or interactive)
    if [[ "$NON_INTERACTIVE" != true ]]; then
        print_header "Step 4: Gateway EUI Detection"
        echo ""
        echo "The Gateway EUI is a unique 64-bit identifier for your gateway."
        echo "This EUI is required to register your gateway on The Things Network."
        echo ""
        echo "Attempting to read EUI from SX1302 chip..."
        echo ""
    else
        log_info "Auto-detecting Gateway EUI from hardware..."
    fi

    if file_executable "$CHIP_ID_TOOL"; then
        log_debug "Using chip_id tool at $CHIP_ID_TOOL"

        # chip_id requires reset_lgw.sh in the same directory
        local chip_id_dir
        chip_id_dir="$(dirname "$CHIP_ID_TOOL")"

        if [[ ! -f "$chip_id_dir/reset_lgw.sh" ]] && file_exists "$RESET_LGW_SCRIPT"; then
            copy_file "$RESET_LGW_SCRIPT" "$chip_id_dir/reset_lgw.sh" "755"
            log_debug "Copied reset_lgw.sh to $chip_id_dir"
        fi

        # Also copy board.conf so reset_lgw.sh uses correct GPIO pins
        if file_exists "$BOARD_CONF"; then
            copy_file "$BOARD_CONF" "$chip_id_dir/board.conf" "644"
            log_debug "Copied board.conf to $chip_id_dir"
        fi

        local chip_output
        log_debug "Running: sudo ./chip_id -d /dev/spidev0.0"
        chip_output=$(cd "$chip_id_dir" && sudo ./chip_id -d /dev/spidev0.0 2>&1) || true
        log_debug "chip_id output: $chip_output"

        detected_eui=$(printf '%s' "$chip_output" | grep -i "concentrator EUI" | sed 's/.*0x\([0-9a-fA-F]*\).*/\1/' | tr '[:lower:]' '[:upper:]') || true

        if [[ -n "$detected_eui" ]] && validate_eui "$detected_eui"; then
            log_info "Detected Gateway EUI: $detected_eui"

            if [[ "$NON_INTERACTIVE" == true ]]; then
                # In non-interactive mode with 'auto', use the detected EUI
                GATEWAY_EUI="$detected_eui"
                return 0
            fi

            echo -e "Detected EUI from SX1302 chip: ${GREEN}$detected_eui${NC}"
            echo ""
            if confirm "Use this EUI?" "y"; then
                GATEWAY_EUI="$detected_eui"
                return 0
            fi
            detected_eui=""
        else
            if [[ "$NON_INTERACTIVE" == true ]]; then
                print_error "Failed to auto-detect Gateway EUI from hardware."
                log_error "EUI detection failed. chip_id output: $chip_output"
                echo "Please specify a valid EUI with --eui instead of 'auto'."
                exit 1
            fi
            print_warning "Could not auto-detect EUI from SX1302 chip."
            log_warning "EUI detection failed. chip_id output: $chip_output"
            if [[ -n "$chip_output" ]]; then
                echo "chip_id output: $chip_output"
            fi
        fi
    else
        if [[ "$NON_INTERACTIVE" == true && "$CLI_EUI" == "auto" ]]; then
            print_error "Cannot auto-detect EUI: chip_id tool not found at $CHIP_ID_TOOL"
            echo "Please build the station first (remove --skip-build) or specify a valid EUI."
            exit 1
        fi
        print_warning "chip_id tool not found at $CHIP_ID_TOOL"
        log_warning "chip_id tool not found at $CHIP_ID_TOOL"
        echo "The tool will be built automatically when you build the station."
    fi

    echo ""
    echo "Please enter your Gateway EUI manually."
    echo "This is a 16-character hex string (e.g., AABBCCDDEEFF0011)"
    echo "You can find this in your TTN Console under Gateway settings."
    echo ""
    read -rp "Gateway EUI: " GATEWAY_EUI

    if ! validate_eui "$GATEWAY_EUI"; then
        print_warning "Warning: Gateway EUI should be 16 hex characters."
        if ! confirm "Continue anyway?"; then
            echo "Setup cancelled."
            exit 1
        fi
    fi

    GATEWAY_EUI=$(printf '%s' "$GATEWAY_EUI" | tr '[:lower:]' '[:upper:]')
}

step_show_registration_instructions() {
    # Skip in non-interactive mode (user should have already registered)
    if [[ "$NON_INTERACTIVE" == true ]]; then
        log_info "Skipping registration instructions (non-interactive mode)"
        return 0
    fi

    echo -e "Gateway EUI: ${GREEN}$GATEWAY_EUI${NC}"
    echo ""
    print_warning "────────────────────────────────────────────────────────────────"
    print_warning "IMPORTANT: Register this gateway in TTN Console before continuing"
    print_warning "────────────────────────────────────────────────────────────────"
    echo ""
    echo "If you haven't already, you need to register this gateway in TTN:"
    echo ""
    echo "  1. Go to: https://console.cloud.thethings.network/"
    echo "  2. Select your region (${TTN_REGION})"
    echo "  3. Navigate to: Gateways > + Register gateway"
    echo "  4. Enter Gateway EUI: ${GATEWAY_EUI}"
    echo "  5. Choose frequency plan matching your hardware"
    echo "  6. Click 'Register gateway'"
    echo ""
    echo "After registration, you'll need to create an API key (next step)."
    echo ""
    read -rp "Press Enter when your gateway is registered in TTN Console... "
    echo ""
}

step_get_cups_key() {
    # Use CLI value if provided
    if [[ -n "$CLI_CUPS_KEY" ]]; then
        CUPS_KEY="$CLI_CUPS_KEY"
        # Strip "Authorization: Bearer " prefix if present
        CUPS_KEY="${CUPS_KEY#Authorization: Bearer }"
        log_info "Using CUPS key from CLI"
        if [[ "$NON_INTERACTIVE" != true ]]; then
            print_success "Using CUPS API key from command line."
            echo ""
        fi
        return 0
    fi

    print_header "Step 5: Enter your CUPS API Key"
    echo ""
    echo "Now create an API key for CUPS in TTN Console:"
    echo ""
    echo "  1. Go to your gateway in TTN Console"
    echo "  2. Navigate to: API Keys > + Add API Key"
    echo "  3. Name it (e.g., 'CUPS Key')"
    echo "  4. Grant rights: 'Link as Gateway to a Gateway Server for traffic"
    echo "     exchange, i.e. write uplink and read downlink'"
    echo "  5. Click 'Create API Key' and copy the key"
    echo ""
    print_warning "Note: The key is only shown once - copy it now!"
    echo ""

    if ! read_secret CUPS_KEY "Paste your API key (it will not be displayed):"; then
        print_error "Error: API key cannot be empty."
        exit 1
    fi

    # Strip "Authorization: Bearer " prefix if user pasted the full string
    CUPS_KEY="${CUPS_KEY#Authorization: Bearer }"

    print_success "API key received."
    echo ""
}

step_setup_trust_cert() {
    print_header "Step 6: Setting up trust certificate..."

    local trust_cert="$CUPS_DIR/cups.trust"

    if file_exists /etc/ssl/certs/ca-certificates.crt; then
        copy_file /etc/ssl/certs/ca-certificates.crt "$trust_cert" "644"
        print_success "Trust certificate installed (system CA bundle)."
    else
        echo "System CA bundle not found, downloading Let's Encrypt root..."
        if curl -sf https://letsencrypt.org/certs/isrgrootx1.pem -o "$trust_cert"; then
            chmod 644 "$trust_cert"
            if [[ ! -s "$trust_cert" ]]; then
                print_error "Error: Downloaded certificate is empty."
                exit 1
            fi
            print_success "Trust certificate downloaded."
        else
            print_error "Error: Could not download trust certificate."
            exit 1
        fi
    fi
    echo ""
}

step_select_log_location() {
    # Use CLI value if provided
    if [[ -n "$CLI_LOG_FILE" ]]; then
        LOG_FILE="$CLI_LOG_FILE"
        log_info "Using log file from CLI: $LOG_FILE"

        # Create log file with proper permissions
        if [[ "$LOG_FILE" == /var/log/* ]]; then
            sudo touch "$LOG_FILE" 2>/dev/null || true
            sudo chown "${USER}:${USER}" "$LOG_FILE" 2>/dev/null || true
            sudo chmod 644 "$LOG_FILE" 2>/dev/null || true
        else
            touch "$LOG_FILE" 2>/dev/null || true
            chmod 644 "$LOG_FILE" 2>/dev/null || true
        fi

        if [[ "$NON_INTERACTIVE" != true ]]; then
            print_success "Using log file: $LOG_FILE"
            echo ""
        fi
        return 0
    fi

    # Default for non-interactive mode if not specified
    if [[ "$NON_INTERACTIVE" == true ]]; then
        LOG_FILE="$CUPS_DIR/station.log"
        touch "$LOG_FILE" 2>/dev/null || true
        chmod 644 "$LOG_FILE" 2>/dev/null || true
        log_info "Using default log file: $LOG_FILE"
        return 0
    fi

    print_header "Step 7: Select log file location"
    echo "  1) Local directory ($CUPS_DIR/station.log)"
    echo "  2) System log (/var/log/station.log) - requires sudo"
    echo ""

    local log_choice
    read -rp "Enter choice [1-2]: " log_choice

    case $log_choice in
        2)
            LOG_FILE="/var/log/station.log"
            print_warning "Note: Creating system log file with proper permissions."
            if confirm "Create log file now with sudo?" "y"; then
                sudo touch "$LOG_FILE"
                sudo chown "${USER}:${USER}" "$LOG_FILE"
                sudo chmod 644 "$LOG_FILE"
                print_success "Log file created: $LOG_FILE"
            fi
            ;;
        *)
            LOG_FILE="$CUPS_DIR/station.log"
            touch "$LOG_FILE"
            chmod 644 "$LOG_FILE"
            print_success "Log file will be: $LOG_FILE"
            ;;
    esac
    echo ""
}

step_detect_gps() {
    # Use CLI value if provided
    if [[ -n "$CLI_GPS" ]]; then
        if [[ "$CLI_GPS" == "none" || "$CLI_GPS" == "false" || "$CLI_GPS" == "disabled" ]]; then
            GPS_DEVICE=""
            log_info "GPS disabled via CLI"
            if [[ "$NON_INTERACTIVE" != true ]]; then
                print_warning "GPS disabled (via --gps none)"
                echo ""
            fi
        else
            GPS_DEVICE="$CLI_GPS"
            log_info "Using GPS device from CLI: $GPS_DEVICE"
            if [[ "$NON_INTERACTIVE" != true ]]; then
                echo -e "Using GPS device: ${GREEN}$GPS_DEVICE${NC}"
                echo ""
            fi
        fi
        return 0
    fi

    print_header "Step 8: GPS Configuration"
    echo ""
    echo "Basic Station can use a GPS module for precise timing and location."
    echo ""

    # Check if GPS scanning was skipped via --skip-gps flag
    if [[ "$SKIP_GPS" == true ]]; then
        log_info "GPS auto-detection skipped (--skip-gps flag)"
        print_warning "GPS auto-detection skipped (--skip-gps flag)."
        echo ""
    else
        print_warning "Note: Scanning serial ports requires sudo and may take 30-60 seconds."
        echo ""

        if confirm "Scan for GPS module?" "y"; then
            echo ""
            echo "Scanning serial ports for GPS NMEA data..."
            echo ""

            if detect_gps_port; then
                echo ""
                echo -e "GPS detected on: ${GREEN}$GPS_DEVICE${NC}"
                echo ""
                if ! confirm "Use this GPS device?" "y"; then
                    GPS_DEVICE=""
                fi
            else
                echo ""
                print_warning "No GPS module detected on standard serial ports."
                echo ""
                echo "This could mean:"
                echo "  - No GPS module is connected"
                echo "  - Serial port is not enabled (check raspi-config)"
                echo "  - GPS module uses a non-standard port/baud rate"
                echo ""
            fi
        else
            log_info "User skipped GPS scan"
            echo ""
        fi
    fi

    if [[ -z "$GPS_DEVICE" ]]; then
        echo "Options:"
        echo "  1) Disable GPS (use network time only)"
        echo "  2) Enter GPS device path manually"
        echo ""

        local gps_choice
        read -rp "Enter choice [1-2]: " gps_choice

        case $gps_choice in
            2)
                echo ""
                echo "Common GPS device paths:"
                echo "  /dev/ttyAMA0   - Pi 5 primary UART"
                echo "  /dev/ttyS0     - Pi 4/3 mini UART"
                echo "  /dev/serial0   - Symlink (varies by Pi model)"
                echo "  /dev/ttyAMA10  - Pi 5 secondary UART"
                echo ""
                read -rp "Enter GPS device path: " GPS_DEVICE
                if [[ ! -c "$GPS_DEVICE" ]]; then
                    print_warning "Warning: Device $GPS_DEVICE does not exist."
                    if ! confirm "Continue anyway?"; then
                        GPS_DEVICE=""
                    fi
                fi
                ;;
            *)
                GPS_DEVICE=""
                print_warning "GPS disabled. Gateway will use network time synchronization."
                ;;
        esac
    fi

    if [[ -n "$GPS_DEVICE" ]]; then
        echo -e "GPS device: ${GREEN}$GPS_DEVICE${NC}"
    fi
    echo ""
}

step_create_credentials() {
    print_header "Step 9: Creating credential files..."

    # Write URI file (not sensitive)
    write_file_secure "$CUPS_DIR/cups.uri" "$CUPS_URI" "644"
    echo "  Created: cups.uri"

    # Write API key file (sensitive - use secure write)
    write_secret_file "$CUPS_DIR/cups.key" "Authorization: Bearer $CUPS_KEY"
    echo "  Created: cups.key (permissions: 600)"

    print_header "Step 10: Generating station.conf..."

    local template="$CUPS_DIR/station.conf.template"
    if file_exists "$template"; then
        # Format GPS_DEVICE and PPS_SOURCE for JSON
        # When GPS is enabled: gps="/dev/ttyXXX", pps="gps"
        # When GPS is disabled: gps="", pps="fuzzy" (uses network time sync)
        local gps_json_value
        local pps_json_value
        if [[ -n "$GPS_DEVICE" ]]; then
            gps_json_value="\"$GPS_DEVICE\""
            pps_json_value="\"gps\""
        else
            gps_json_value="\"\""
            pps_json_value="\"fuzzy\""
        fi

        process_template "$template" "$CUPS_DIR/station.conf" \
            "GATEWAY_EUI=$GATEWAY_EUI" \
            "INSTALL_DIR=$SCRIPT_DIR" \
            "LOG_FILE=$LOG_FILE" \
            "GPS_DEVICE=$gps_json_value" \
            "PPS_SOURCE=$pps_json_value"
        chmod 644 "$CUPS_DIR/station.conf"
        echo "  Created: station.conf"
    else
        print_warning "Warning: station.conf.template not found. Please configure station.conf manually."
    fi

    print_header "Step 11: Setting file permissions..."
    chmod 600 "$CUPS_DIR/cups.key" 2>/dev/null || true
    chmod 600 "$CUPS_DIR/tc.key" 2>/dev/null || true
    chmod 644 "$CUPS_DIR/cups.uri" 2>/dev/null || true
    chmod 644 "$CUPS_DIR/cups.trust" 2>/dev/null || true
    chmod 644 "$CUPS_DIR/station.conf" 2>/dev/null || true
    echo "  Permissions set."
}

step_setup_service() {
    local service_name="basicstation.service"
    local service_was_active=false
    local setup_service=false

    if service_is_active "$service_name"; then
        service_was_active=true
    fi

    # Determine whether to setup service
    if [[ -n "$CLI_SERVICE" ]]; then
        if [[ "$CLI_SERVICE" == "yes" ]]; then
            setup_service=true
            log_info "Setting up systemd service (--service flag)"
        else
            setup_service=false
            log_info "Skipping systemd service setup (--no-service flag)"
            if [[ "$NON_INTERACTIVE" != true ]]; then
                print_summary "manual"
            else
                print_summary_quiet "manual"
            fi
            return 0
        fi
    else
        if [[ "$NON_INTERACTIVE" != true ]]; then
            echo ""
            print_header "Step 12: Gateway startup configuration"
            echo ""
            if ! confirm "Do you want to run the gateway as a systemd service?"; then
                print_summary "manual"
                return 0
            fi
            setup_service=true
        fi
    fi

    if [[ "$setup_service" != true ]]; then
        return 0
    fi

    if [[ "$NON_INTERACTIVE" != true ]]; then
        echo ""
        print_success "Setting up systemd service..."
    else
        log_info "Setting up systemd service..."
    fi

    local service_file="/etc/systemd/system/$service_name"

    # Create service file content
    local service_content
    read -r -d '' service_content << EOF || true
[Unit]
Description=LoRa Basics Station (SX1302/Corecell) for TTN (CUPS)
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=root
WorkingDirectory=$SCRIPT_DIR

ExecStart=$STATION_BINARY --home $CUPS_DIR

Restart=on-failure
RestartSec=5
SuccessExitStatus=143

# Security hardening
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=full
ProtectHome=false
ProtectKernelTunables=false
ProtectKernelModules=true
ProtectControlGroups=true

# Logs
StandardOutput=journal
StandardError=journal
SyslogIdentifier=basicstation

[Install]
WantedBy=multi-user.target
EOF

    # Write service file via sudo
    printf '%s\n' "$service_content" | sudo tee "$service_file" > /dev/null
    if [[ "$NON_INTERACTIVE" != true ]]; then
        echo "  Created: $service_file"
    fi
    log_info "Created service file: $service_file"

    sudo systemctl daemon-reload
    sudo systemctl enable "$service_name"
    if [[ "$NON_INTERACTIVE" != true ]]; then
        echo "  Service enabled."
    fi
    log_info "Service enabled"

    local service_started=false
    if [[ "$service_was_active" == true ]]; then
        if [[ "$NON_INTERACTIVE" != true ]]; then
            print_warning "Service was already running. Restarting with new configuration..."
        fi
        log_info "Restarting service..."
        service_restart "$service_name" || true
        service_started=true
    elif [[ "$NON_INTERACTIVE" == true ]]; then
        # In non-interactive mode, always start the service
        log_info "Starting service..."
        service_start "$service_name" || true
        service_started=true
    elif confirm "Do you want to start the service now?" "y"; then
        service_start "$service_name" || true
        service_started=true
    else
        echo ""
        echo "To start the service later, run:"
        print_warning "  sudo systemctl start $service_name"
    fi

    # Verify gateway actually started if service was started/restarted
    if [[ "$service_started" == true ]]; then
        verify_gateway_started || true
    fi

    if [[ "$NON_INTERACTIVE" != true ]]; then
        print_summary "service"
    else
        print_summary_quiet "service"
    fi
}

verify_gateway_started() {
    local timeout=30
    local interval=2
    local elapsed=0

    echo ""
    while [[ $elapsed -lt $timeout ]]; do
        printf "\rVerifying gateway startup... (%d/%ds)" "$elapsed" "$timeout"

        # Check station.log for "Concentrator started"
        if [[ -f "$LOG_FILE" ]] && grep -q "Concentrator started" "$LOG_FILE" 2>/dev/null; then
            printf "\r%-50s\n" ""  # Clear the line
            print_success "Gateway concentrator started successfully!"
            return 0
        fi
        # Also check journalctl if using systemd
        if journalctl -u basicstation.service --since "1 minute ago" 2>/dev/null | grep -q "Concentrator started"; then
            printf "\r%-50s\n" ""  # Clear the line
            print_success "Gateway concentrator started successfully!"
            return 0
        fi
        sleep $interval
        elapsed=$((elapsed + interval))
    done

    printf "\r%-50s\n" ""  # Clear the line
    print_warning "Could not verify concentrator startup within ${timeout}s."
    print_warning "Check logs manually: tail -f $LOG_FILE"
    return 1
}

print_summary() {
    local mode="$1"

    echo ""
    print_banner "Setup Complete!"
    echo "Your gateway is configured with:"
    echo "  Board:       $BOARD_TYPE"
    echo "  Region:      $TTN_REGION"
    echo "  Gateway EUI: $GATEWAY_EUI"
    echo "  GPS device:  ${GPS_DEVICE:-disabled}"
    echo "  Config dir:  $CUPS_DIR"
    echo "  Log file:    $LOG_FILE"
    echo ""
    echo "Setup log:     $(get_log_file)"
    echo ""

    if [[ "$mode" == "service" ]]; then
        echo "Useful commands:"
        print_warning "  sudo systemctl status basicstation.service   - Check service status"
        print_warning "  sudo systemctl restart basicstation.service  - Restart the service"
        print_warning "  sudo journalctl -u basicstation.service -f   - View live systemd logs"
        print_warning "  tail -n 100 $LOG_FILE  - View station log"
    else
        echo "To start the gateway manually:"
        print_warning "  cd $SCRIPT_DIR/examples/corecell"
        print_warning "  ./start-station.sh -l ./cups-ttn"
        echo ""
        print_warning "Note: You may need to run start-station.sh with sudo for GPIO access."
    fi
}

# Quiet summary for non-interactive mode (logs only)
print_summary_quiet() {
    local mode="$1"

    log_info "=== Setup Complete ==="
    log_info "Board: $BOARD_TYPE"
    log_info "Region: $TTN_REGION"
    log_info "Gateway EUI: $GATEWAY_EUI"
    log_info "GPS device: ${GPS_DEVICE:-disabled}"
    log_info "Config dir: $CUPS_DIR"
    log_info "Log file: $LOG_FILE"
    log_info "Mode: $mode"
}

#######################################
# Main Setup Function
#######################################

run_setup() {
    print_banner "LoRa Basic Station Setup for TTN"

    log_info "=== Starting setup wizard ==="

    # Check dependencies before proceeding
    if [[ "$SKIP_DEPS" == true ]]; then
        log_warning "Skipping dependency checks (--skip-deps flag)"
        print_warning "Skipping dependency checks as requested."
        echo ""
    elif ! check_all_dependencies; then
        print_error "Cannot proceed without required dependencies."
        echo "Please install the missing packages and try again."
        echo ""
        echo "Use --skip-deps to bypass this check (not recommended)."
        exit 1
    fi

    step_check_existing_credentials
    log_debug "Completed: check_existing_credentials"

    step_select_board
    log_debug "Completed: select_board"

    step_build_station
    log_debug "Completed: build_station"

    step_select_region
    log_info "Selected region: $TTN_REGION"

    step_detect_eui
    log_info "Gateway EUI: $GATEWAY_EUI"

    step_show_registration_instructions

    step_get_cups_key
    log_debug "Completed: get_cups_key (key received)"

    step_setup_trust_cert
    log_debug "Completed: setup_trust_cert"

    step_select_log_location
    log_info "Log file location: $LOG_FILE"

    step_detect_gps
    log_info "GPS device: ${GPS_DEVICE:-disabled}"

    step_create_credentials
    log_debug "Completed: create_credentials"

    step_setup_service
    log_info "=== Setup wizard completed ==="
}
